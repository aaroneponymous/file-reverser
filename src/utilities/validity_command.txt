python3 - <<'PY'
import os
from pathlib import Path

ROOT = Path(".")
IN_DIR = ROOT / "input"
OUT_DIR = ROOT / "output"

def reverse_line_bytes(line: bytes) -> bytes:
    # Preserve EOL exactly, reverse only content before it
    eol = b""
    content = line
    if line.endswith(b"\n"):
        if line.endswith(b"\r\n"):
            eol = b"\r\n"
            content = line[:-2]
        else:
            eol = b"\n"
            content = line[:-1]

    # Reverse by UTF-8 code points; fallback to raw bytes if decode fails
    try:
        s = content.decode("utf-8")
        rev = s[::-1].encode("utf-8")
    except UnicodeDecodeError:
        rev = content[::-1]
    return rev + eol

def first_mismatch(a: bytes, b: bytes) -> int:
    n = min(len(a), len(b))
    for i in range(n):
        if a[i] != b[i]:
            return i
    return n if len(a) != len(b) else -1

tested = 0
passed = 0

inputs = sorted(IN_DIR.glob("*.txt"))
if not inputs:
    print(f"No input files found in {IN_DIR}")
    raise SystemExit(1)

for in_path in inputs:
    out_path = OUT_DIR / in_path.name
    if not out_path.exists():
        print(f"SKIP  {in_path.name} (no matching output/{in_path.name})")
        continue

    tested += 1
    ok = True

    with in_path.open("rb") as fin, out_path.open("rb") as fout:
        line_no = 0
        while True:
            in_line = fin.readline()
            out_line = fout.readline()

            if not in_line and not out_line:
                break
            if not in_line or not out_line:
                ok = False
                where = "input ended early" if not in_line else "output ended early"
                print(f"FAIL  {in_path.name}: {where} at line {line_no+1}")
                break

            line_no += 1
            exp = reverse_line_bytes(in_line)
            if exp != out_line:
                ok = False
                idx = first_mismatch(exp, out_line)

                # Show a short preview around mismatch
                def preview(x: bytes, i: int, w: int = 40) -> str:
                    lo = max(0, i - w)
                    hi = min(len(x), i + w)
                    return x[lo:hi].decode("utf-8", errors="replace").replace("\n", "\\n").replace("\r", "\\r")

                print(f"FAIL  {in_path.name}: line {line_no}, byte {idx}")
                print(f"  exp: ...{preview(exp, idx)}...")
                print(f"  out: ...{preview(out_line, idx)}...")
                break

        # Also ensure output doesn't have extra lines
        if ok:
            extra = fout.readline()
            if extra:
                ok = False
                print(f"FAIL  {in_path.name}: output has extra data after line {line_no}")

    if ok:
        passed += 1
        print(f"PASS  {in_path.name}")

print(f"\nSummary: {passed}/{tested} passed (skipped {len(inputs)-tested})")
PY
